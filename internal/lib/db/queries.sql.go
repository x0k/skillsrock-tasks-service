// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allTasks = `-- name: AllTasks :many
SELECT id, title, description, status, priority, due_date, created_at, updated_at FROM task
`

func (q *Queries) AllTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, allTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.DueDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const averageTaskCompletionTime = `-- name: AverageTaskCompletionTime :one
SELECT
  AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) AS average_completion_time
FROM
    task
WHERE
    task.status = 'done'
`

func (q *Queries) AverageTaskCompletionTime(ctx context.Context) (float64, error) {
	row := q.db.QueryRow(ctx, averageTaskCompletionTime)
	var average_completion_time float64
	err := row.Scan(&average_completion_time)
	return average_completion_time, err
}

const countCompletedAndOverdueTasks = `-- name: CountCompletedAndOverdueTasks :one
WITH last_week_task AS (
  SELECT id, title, description, status, priority, due_date, created_at, updated_at
  FROM task
  WHERE updated_at >= $1
)
SELECT
  (SELECT count(*) FROM last_week_task WHERE status = 'done') AS completed_count,
  (SELECT count(*) FROM last_week_task WHERE status != 'done' AND due_date < CURRENT_DATE) AS overdue_count
`

type CountCompletedAndOverdueTasksRow struct {
	CompletedCount int64
	OverdueCount   int64
}

func (q *Queries) CountCompletedAndOverdueTasks(ctx context.Context, updatedAt pgtype.Timestamp) (CountCompletedAndOverdueTasksRow, error) {
	row := q.db.QueryRow(ctx, countCompletedAndOverdueTasks, updatedAt)
	var i CountCompletedAndOverdueTasksRow
	err := row.Scan(&i.CompletedCount, &i.OverdueCount)
	return i, err
}

const countTasksByStatus = `-- name: CountTasksByStatus :many
SELECT count(*) AS tasks_count, status FROM task GROUP BY status
`

type CountTasksByStatusRow struct {
	TasksCount int64
	Status     TaskStatus
}

func (q *Queries) CountTasksByStatus(ctx context.Context) ([]CountTasksByStatusRow, error) {
	rows, err := q.db.Query(ctx, countTasksByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountTasksByStatusRow
	for rows.Next() {
		var i CountTasksByStatusRow
		if err := rows.Scan(&i.TasksCount, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteOverdueTasks = `-- name: DeleteOverdueTasks :exec
DELETE FROM task WHERE status != 'done' and due_date < $1
`

func (q *Queries) DeleteOverdueTasks(ctx context.Context, dueDate pgtype.Date) error {
	_, err := q.db.Exec(ctx, deleteOverdueTasks, dueDate)
	return err
}

const deleteTask = `-- name: DeleteTask :execrows
DELETE FROM task WHERE task.id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const insertTask = `-- name: InsertTask :exec
INSERT INTO task
  (id, title, description, status, priority, due_date, created_at, updated_at)
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertTaskParams struct {
	ID          pgtype.UUID
	Title       string
	Description pgtype.Text
	Status      TaskStatus
	Priority    TaskPriority
	DueDate     pgtype.Date
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) error {
	_, err := q.db.Exec(ctx, insertTask,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.DueDate,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO "user" (login, password_hash) VALUES ($1, $2)
`

type InsertUserParams struct {
	Login        string
	PasswordHash []byte
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser, arg.Login, arg.PasswordHash)
	return err
}

const updateTask = `-- name: UpdateTask :execrows
UPDATE task SET
  title = $2,
  description = $3,
  status = $4,
  priority = $5,
  due_date = $6,
  updated_at = CURRENT_DATE
WHERE
  task.id = $1 AND task.status != 'done'
`

type UpdateTaskParams struct {
	ID          pgtype.UUID
	Title       string
	Description pgtype.Text
	Status      TaskStatus
	Priority    TaskPriority
	DueDate     pgtype.Date
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTask,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.DueDate,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const userById = `-- name: UserById :one
SELECT login, password_hash FROM "user" WHERE login = $1
`

func (q *Queries) UserById(ctx context.Context, login string) (User, error) {
	row := q.db.QueryRow(ctx, userById, login)
	var i User
	err := row.Scan(&i.Login, &i.PasswordHash)
	return i, err
}
